project.version = getVersion()
println "Building version ${project.version}"

allprojects {
  repositories {
    mavenCentral()
    mavenLocal()
  }
}

buildscript {
  repositories {
    maven {
      setUrl("https://plugins.gradle.org/m2/")
    }
  }
  dependencies {
    classpath 'org.openjfx:javafx-plugin:0.0.10'
  }
}

subprojects {
  apply plugin: 'java'
  apply plugin: 'jacoco'
  apply plugin: 'org.openjfx.javafxplugin'

  group = 'se.llbit'
  version = rootProject.version

  sourceCompatibility = '1.8'
  targetCompatibility = '1.8'

  compileJava.options.encoding = 'UTF-8'
  compileJava.options.debug = true

  javafx {
    version = '11'
    modules = ['javafx.base', 'javafx.controls', 'javafx.fxml']
    configuration = 'implementation'
  }

  javadoc {
    options.encoding = 'UTF-8'
    options.addStringOption('Xdoclint:none', '-quiet')
  }

  configurations {
    jsonlib
    nbtlib
    cplib
    toolpanelib
  }

  dependencies {
    jsonlib 'se.llbit:jo-json:1.3.1'
    nbtlib 'se.llbit:jo-nbt:1.3.0'
    cplib 'se.llbit:luxcp:1.0.1'
    toolpanelib 'se.llbit:toolpane:0.1'
  }
}

defaultTasks 'releaseJar'

//task release {
//  doLast {
//    tryCommand([ 'git', 'commit', '-m', "Release ${project.version}", 'chunky/src/res/se/llbit/chunky/main/Version.properties' ], true)
//    tryCommand([ 'git', 'tag', '-a', "${project.version}", '-m', "Version ${project.version}" ], true)
//  }
//}

task versionInfo(type: JavaExec) {
  dependsOn 'copyArtifacts'

  outputs.files file("build/chunky-${project.version}.jar")
  description 'Writes build/chunky-VERSION.jar, latest.json and updates chunky-core-VERSION.jar/version.json'
  classpath = project(':releasetools').sourceSets.main.runtimeClasspath
  mainClass.set('releasetools.ReleaseBuilder')
  args "${project.version}", "release_notes-${project.version}.txt"
}

task releaseJar(type: Jar) {
  dependsOn 'versionInfo'

  archiveFileName = "chunky-${project.version}.jar"
  destinationDirectory = file('build')
  manifest {
    attributes('Main-Class': 'se.llbit.chunky.launcher.ChunkyLauncher')
  }

  into('') {
    from file('latest.json')
    rename { 'version.json' }
  }

  into('lib') {
    from fileTree('chunky/lib').include('*.jar')
    from file("build/chunky-core-${project.version}.jar")
  }

  from {
    project(':launcher').configurations.archives.allArtifacts.files.collect {
      zipTree(it)
    }
  }
}

task releaseZip(type: Zip) {
  dependsOn 'copyArtifacts'

  destinationDirectory = buildDir
  archiveFileName = "Chunky-${project.version}.zip"

  from(buildDir) {
    include "chunky-${project.version}.jar"
    include "ReadMe.html"
    include "release_notes-${project.version}.txt"
  }
  from(projectDir) {
    include 'license/*'
  }
  rename("release_notes-${project.version}.jar", 'chunky.jar')
}

task documentation {
  inputs.files 'README.md'
  outputs.files 'build/ReadMe.html'

  doLast {
    def readme = tryCommand([ 'perl', file('tools/Markdown.pl').path, file('README.md').path ], true)
    file('build/ReadMe.html').write(readme)
  }
}

task copyArtifacts(type: Copy) {
  dependsOn subprojects.jar
  from subprojects.jar
  into buildDir
}

/** Helper function to run a command. Returns the command output if the command succeeded. */
def tryCommand(def command, boolean failOnError = false) {
  def out = new StringBuilder()
  def err = new StringBuilder()
  try {
    def proc = command.execute()
    proc.waitForProcessOutput(out, err)
    if (proc.exitValue()) {
      def msg = "failed to run '${command[0]}' (args: ${command.tail()})\n$err$out"
      if (failOnError) {
        throw new GradleException(msg)
      } else {
        print 'Warning: '
        println msg
      }
      ""
    } else {
      if (err) println "${err}"
      out.toString()
    }
  } catch (IOException e) {
    println "failed to run ${command[0]} (args: ${command.tail()}): $e"
    ""
  }
}

/** Helper function to retrieve the current version string. */
def getVersion() {
  if (project.hasProperty('newVersion')) {
    // Manual version override
    return project.newVersion
  }

  // Prerelease version based on stored version and git history
  def prerelease = "DEV"
  if (project.hasProperty('prereleaseTag')) {
    prerelease = project.prereleaseTag
  }

  // Get the stored major version
  Properties versionProperties = new Properties()
  versionProperties.load(new FileInputStream(file('chunky/src/res/se/llbit/chunky/main/Version.properties')))
  def majorVersion = versionProperties['version']

  def preVersion = "0";
  // Attempt to get Git describe output
  def gitDescribe = tryCommand(['git', 'describe', '--abbrev=7', '--long'])
  if (gitDescribe) {
    def gitMatcher = gitDescribe =~ /^.*?-(\d*)-(g.*)/
    gitMatcher.find()
    if (gitMatcher.groupCount() >= 2) {
      preVersion = gitMatcher.group(1) + "." + gitMatcher.group(2)
    }
  }

  return majorVersion + "-" + prerelease + "." + preVersion
}

task install(dependsOn: ':chunky:install') {
    copy {
        from file("${project(':chunky').buildDir}/maven/")
        into file("${buildDir}/maven/")
    }
}

// Includes both main and library documentation:
task docs(type: Javadoc) {
    options.encoding = 'UTF-8'
    options.addStringOption('Xdoclint:none', '-quiet')

    def docProjects = [ ':chunky', ':lib' ]
    source docProjects.collect { project(it).sourceSets.main.allJava }
    classpath = files(docProjects.collect { project(it).sourceSets.main.compileClasspath })
    destinationDir = file("${buildDir}/docs/javadoc")
}
